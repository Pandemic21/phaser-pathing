<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Adding meta -->
    

    <!-- Adding external script-->
    

    <!-- Adding external style-->
    

    <!-- Adding scripts-->
    

    <!-- Adding style-->
    

    <!-- Adding overlay script-->
    

    <!-- Adding overlay style-->
    


    <title>
      ClientGameScene.js
    </title>

    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/third-party/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/third-party/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/reset.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-base.css">
    <link type="text/css" rel="stylesheet" href="styles/clean-jsdoc-theme-dark.css">
    
    <svg aria-hidden="true" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"
    style="display:none">
    <defs>
        <symbol id="copy-icon" viewbox="0 0 488.3 488.3">
            <g>
                <path
                    d="M314.25,85.4h-227c-21.3,0-38.6,17.3-38.6,38.6v325.7c0,21.3,17.3,38.6,38.6,38.6h227c21.3,0,38.6-17.3,38.6-38.6V124    C352.75,102.7,335.45,85.4,314.25,85.4z M325.75,449.6c0,6.4-5.2,11.6-11.6,11.6h-227c-6.4,0-11.6-5.2-11.6-11.6V124    c0-6.4,5.2-11.6,11.6-11.6h227c6.4,0,11.6,5.2,11.6,11.6V449.6z" />
                <path
                    d="M401.05,0h-227c-21.3,0-38.6,17.3-38.6,38.6c0,7.5,6,13.5,13.5,13.5s13.5-6,13.5-13.5c0-6.4,5.2-11.6,11.6-11.6h227    c6.4,0,11.6,5.2,11.6,11.6v325.7c0,6.4-5.2,11.6-11.6,11.6c-7.5,0-13.5,6-13.5,13.5s6,13.5,13.5,13.5c21.3,0,38.6-17.3,38.6-38.6    V38.6C439.65,17.3,422.35,0,401.05,0z" />
            </g>
        </symbol>
        <symbol id='search-icon' viewBox="0 0 512 512">
            <g>
                <g>
                    <path
                        d="M225.474,0C101.151,0,0,101.151,0,225.474c0,124.33,101.151,225.474,225.474,225.474    c124.33,0,225.474-101.144,225.474-225.474C450.948,101.151,349.804,0,225.474,0z M225.474,409.323    c-101.373,0-183.848-82.475-183.848-183.848S124.101,41.626,225.474,41.626s183.848,82.475,183.848,183.848    S326.847,409.323,225.474,409.323z" />
                </g>
            </g>
            <g>
                <g>
                    <path
                        d="M505.902,476.472L386.574,357.144c-8.131-8.131-21.299-8.131-29.43,0c-8.131,8.124-8.131,21.306,0,29.43l119.328,119.328    c4.065,4.065,9.387,6.098,14.715,6.098c5.321,0,10.649-2.033,14.715-6.098C514.033,497.778,514.033,484.596,505.902,476.472z" />
                </g>
            </g>
        </symbol>
        <symbol id="down-icon" viewBox="0 0 16 16">
            <path 
                fill-rule="evenodd" 
                clip-rule="evenodd" 
                d="M12.7803 6.21967C13.0732 6.51256 13.0732 6.98744 12.7803 7.28033L8.53033 11.5303C8.23744 11.8232 7.76256 11.8232 7.46967 11.5303L3.21967 7.28033C2.92678 6.98744 2.92678 6.51256 3.21967 6.21967C3.51256 5.92678 3.98744 5.92678 4.28033 6.21967L8 9.93934L11.7197 6.21967C12.0126 5.92678 12.4874 5.92678 12.7803 6.21967Z"
            >
            </path>
        </symbol>
    </defs>
</svg>
  </head>

  <body>

    <nav class="navbar" id="navbar">
      <div class="navbar-heading" id="navbar-heading"><a href="index.html"><h2 class="navbar-heading-text">Home</h2></a></div><div class="search-box" id="search-box"><div class="search-box-input-container"><input class="search-box-input" type="text" placeholder="Search..." id="search-box-input" /><svg class="search-icon" alt="search-icon"><use xlink:href="#search-icon"></use></svg></div><div class="search-item-container" id="search-item-container"><ul class="search-item-ul" id="search-item-ul"></ul></div></div><div class="sidebar-main-content" id="sidebar-main-content"><div class="accordion collapsed" id="1621443" > <h3 class="accordion-heading">Classes<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="Circle.html">Circle</a></li><li class="accordion-list" id=""><a href="ColorData.html">ColorData</a></li><li class="accordion collapsed child" id=6950733><div class="accordion-heading child"><a href="Location.html">Location</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Location.html#toString">toString</a></li></ul></li><li class="accordion collapsed child" id=8093323><div class="accordion-heading child"><a href="MainMenu.html">MainMenu</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="MainMenu.html#create">create</a></li><li data-type='method'><a href="MainMenu.html#createButton">createButton</a></li><li data-type='method'><a href="MainMenu.html#init">init</a></li></ul></li><li class="accordion collapsed child" id=8341223><div class="accordion-heading child"><a href="Rectangle.html">Rectangle</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="Rectangle.html#toString">toString</a></li></ul></li><li class="accordion collapsed child" id=3483286><div class="accordion-heading child"><a href="UIHelper.html">UIHelper</a><svg><use xlink:href="#down-icon"></use></svg></div><ul class='methods accordion-content'><li data-type='method'><a href="UIHelper.html#.createBackButton">createBackButton</a></li><li data-type='method'><a href="UIHelper.html#.createButton">createButton</a></li><li data-type='method'><a href="UIHelper.html#.createRadioButton">createRadioButton</a></li><li data-type='method'><a href="UIHelper.html#.getBackButton">getBackButton</a></li><li data-type='method'><a href="UIHelper.html#.getButton">getButton</a></li><li data-type='method'><a href="UIHelper.html#.getFont">getFont</a></li><li data-type='method'><a href="UIHelper.html#.getHealthBar">getHealthBar</a></li><li data-type='method'><a href="UIHelper.html#.getManaColors">getManaColors</a></li><li data-type='method'><a href="UIHelper.html#.getManaOrb">getManaOrb</a></li><li data-type='method'><a href="UIHelper.html#.getRuneSlot">getRuneSlot</a></li><li data-type='method'><a href="UIHelper.html#.getScreenHeight">getScreenHeight</a></li><li data-type='method'><a href="UIHelper.html#.getScreenWidth">getScreenWidth</a></li><li data-type='method'><a href="UIHelper.html#.getUIColors">getUIColors</a></li><li data-type='method'><a href="UIHelper.html#.setCameraBackgroundColor">setCameraBackgroundColor</a></li><li data-type='method'><a href="UIHelper.html#.shuffle">shuffle</a></li></ul></li></ul> </div><div class="accordion collapsed" id="9950738" > <h3 class="accordion-heading">Global<svg><use xlink:href="#down-icon"></use></svg></h3><ul class="accordion-content"><li class="accordion-list" id=""><a href="global.html#drawMovementDestinationImage">drawMovementDestinationImage</a></li><li class="accordion-list" id=""><a href="global.html#findNearbyWalkablePoint">findNearbyWalkablePoint</a></li></ul> </div></div>
      

    </nav>
    <div class="navbar-ham" id="navbar-ham">
      <div>
        <div class="first"></div>
        <div class="second"></div>
        <div class="third"></div>
      </div>
    </div>

    <div id="main" class="main-content">
      
      <h1 id='page-title' class="page-title">
        ClientGameScene.js
      </h1>
      

      



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>export default class ClientGameScene extends Phaser.Scene {
    constructor() {
        super();
    }

    init() {

    }

    preload() {
        ////////////
        // Images //
        ////////////

        this.load.image('isaacImg', './assets/sliced/creatures_24x24/oryx_16bit_fantasy_creatures_04.png');
        this.load.image('isaacBreathe', './assets/sliced/creatures_24x24/oryx_16bit_fantasy_creatures_22.png');

        this.load.image('orb', './assets/sliced/fx_24x24/oryx_16bit_fantasy_fx2_42.png');
        this.load.image('movementClick', './assets/sliced/fx_24x24/oryx_16bit_fantasy_fx2_53.png');

        this.load.image('movementClick', './assets/sliced/fx_24x24/oryx_16bit_fantasy_fx2_53.png');


        ///////////
        // Audio //
        ///////////

        this.load.audio('movementClickSound', "./assets/sounds/Bluezone_BC0268_switch_button_click_small_005.wav");
        this.load.audio('movementClickBlip', "./assets/sounds/Blip.mp3");


        /////////
        // Map //
        /////////

        this.load.image("base_tiles", "../assets/maps/oryx_world.png");

        //this.load.tilemapTiledJSON("tilemap", "../assets/maps/forest_map_small_v2.json")
        //this.load.tilemapTiledJSON("tilemap", "../assets/maps/forest_map_100x100_v1.json")
        this.load.tilemapTiledJSON("tilemap", "../assets/maps/forest_map_100x100_v2.json");
    }

    create() {
        ///////////////
        // Constants //
        ///////////////

        const PLAYER_SPEED = 50; // lower is faster
        const TICK_RATE = 50; // how fast we receive gameState snapshots. this needs to be the same on the server and the client.


        //////////////////
        // Map Creation //
        //////////////////

        // create the Tilemap
        let map = this.make.tilemap({
            key: 'tilemap',
            tileWidth: 24,
            tileHeight: 24
        });

        // add the tileset image we are using
        const tileset = map.addTilesetImage('oryx_world', 'base_tiles');

        // "Ground" layer will be first
        let ground = map.createLayer('Ground', tileset);

        // "Trees" layer will be second
        let treesLayer = map.createStaticLayer('Trees', tileset);


        // map height and width in raw pixels (used for minimap)
        this.MAP_WIDTH_PIXELS = map.width * map.tileWidth;
        this.MAP_HEIGHT_PIXELS = map.height * map.tileHeight;


        ////////////
        // Camera //
        ////////////

        // setup camera config
        const cursors = this.input.keyboard.createCursorKeys();

        const controlConfig = {
            camera: this.cameras.main,
            left: cursors.left,
            right: cursors.right,
            up: cursors.up,
            down: cursors.down,
            zoomIn: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.Q),
            zoomOut: this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.E),
            acceleration: 0.06,
            drag: 0.0005,
            maxSpeed: 1.0
        };

        // declare the camera
        this.controls = new Phaser.Cameras.Controls.SmoothedKeyControl(controlConfig);
        this.camera = this.cameras.main;
        this.camera.setBounds(0, 0, this.MAP_WIDTH_PIXELS, this.MAP_HEIGHT_PIXELS);


        /////////////
        // Minimap //
        /////////////

        // constants and variables
        this.SCREEN_WIDTH = 800;
        this.SCREEN_HEIGHT = 600;

        this.MINIMAP_WIDTH = this.SCREEN_WIDTH / 4;
        this.MINIMAP_HEIGHT = this.SCREEN_HEIGHT / 4;
        this.MINIMAP_ZOOM = 0.2;
        this.MINIMAP_X = this.SCREEN_WIDTH - this.MINIMAP_WIDTH; // right side of the screen
        this.MINIMAP_Y = this.SCREEN_HEIGHT - this.MINIMAP_HEIGHT; // bottom of the screen

        // declare this.minimap
        this.minimap = this.cameras.add(
            this.MINIMAP_X,
            this.MINIMAP_Y,
            this.MINIMAP_WIDTH,
            this.MINIMAP_HEIGHT)
            .setZoom(0.2)
            .setName('mini')
            .setBackgroundColor(0x002244);

        //////////////////////
        // Socket.io Config //
        //////////////////////

        this.socket = io();

        this.players = [];   // this array contains all the player's in the game
        this.myId = '';      // this is the current player's id
        this.gameStates = [] // this is the array of snapshots we will tween through



        // This is called by server.js when the player first connects
        // it sends "&lt;array> players", which contains all players in the game
        this.socket.on('initialConnectionConfig', (players) => {
            ////////////
            // Player //
            ////////////

            this.myId = this.socket.id;  // set "this.myId"
            this.players = players; // set "&lt;array> this.players" equal to what the server has

            // this plucks the current player out of "&lt;array> players" the server sent
            let myPlayer = players.find((player) => {
                return player.id == this.myId;
            });

            // create sprite graphics for all player's mages
            for (let k = 0; k &lt; players.length; k++) {
              console.log(players[k].id);
              players[k].mage = this.physics.add.sprite(players[k].mage.x, players[k].mage.y, 'isaacImg');
            }
        });

        // this is called by server.js whenever a new player joins
        this.socket.on('newPlayerJoined', (newPlayer) => {
            console.log("New player joined: " + newPlayer.id);

            // add the new player to "&lt;array> this.players"
            this.players.push(newPlayer);

            // draw the new player's mage
            newPlayer.mage = this.physics.add.sprite(newPlayer.mage.x, newPlayer.mage.y, 'isaacImg');
        });

        this.socket.on('setUpdate', (gameState) => {
          //add the new snapshot to our gameStates array
          this.gameStates.push(gameState);

          //nothing to tween if theres not at least two snapshots
          if(this.gameStates.length &lt; 2) return;

          const stateA = this.gameStates[this.gameStates.length-2];
          const stateB = this.gameStates[this.gameStates.length-1];

          stateA.players.forEach((player) => {
            const currentPlayer = this.players.find((p) => {
              return p.id === player.id
            })
            if(currentPlayer) {
              currentPlayer.mage.fromX = player.x
              currentPlayer.mage.fromY = player.y
            }

          });

          stateB.players.forEach((player) => {
            const currentPlayer = this.players.find((p) => {
              return p.id === player.id
            })
            if(currentPlayer){
              currentPlayer.mage.toX = player.x
              currentPlayer.mage.toY = player.y
            }

          });

          this.calculateTweens(TICK_RATE);


        })

        ////////////////////////////////////////////
        // Listener Config (e.g. spacebar, click) //
        ////////////////////////////////////////////

        // spacebar re-centers the camera on "myPlayer.mage"
        this.input.keyboard.on('keyup-SPACE', (keyPress) => {
            // get this player
            // let myPlayer = this.players.find((player) => {
            //     return player.id == this.myId;
            // })
            let myPlayer = this.players.find(player => player.id == this.myId);

            // if "myPlayer" exists, center the camera on "myPlayer.mage"
            if (myPlayer) {
                this.camera.scrollX = myPlayer.mage.x - this.SCREEN_WIDTH / 2;
                this.camera.scrollY = myPlayer.mage.y - this.SCREEN_HEIGHT / 2;
            }
        });

        // toggle follscreen on keypress: F
        this.input.keyboard.on('keyup-F', (keyPress) => {
            // if it's fullscreen already, toggle fullscreen off
            if (this.scale.isFullscreen) {
                this.scale.stopFullscreen();
            }
            // if it's not fullscreen, toggle fullscreen on
            else {
                this.scale.startFullscreen();
            }
        });

        // pan the camera around with the mouse
        this.input.on('pointermove', (pointer) => {
            // the is not holding RMB, stop panning the camera
            if (!pointer.rightButtonDown()) return;

            // adjust the camera
            const SCROLL_SPEED = 2;

            // SCROLL_SPEED adjusts how fast the camera moves
            this.camera.scrollX -= (pointer.x - pointer.prevPosition.x) / this.camera.zoom * SCROLL_SPEED;
            this.camera.scrollY -= (pointer.y - pointer.prevPosition.y) / this.camera.zoom * SCROLL_SPEED;
        });

        // Mouse (left and right mouse click)
        this.input.on('pointerdown', (pointer) => {
            // if RMB (right click)
            if (pointer.rightButtonDown()) {
                // do stuff
            }

            // else it's LMB, move the player to the destination
            else {
                // draw the "click to move" image and debug console logs
                this.drawMovementDestinationImage({
                    x: this.input.mousePointer.x + this.camera.scrollX,
                    y: this.input.mousePointer.y + this.camera.scrollY
                });

                // destination location (x,y) the player clicked

                /**
                 * This object contains all information required for the client use/draw fonts
                 * @type {Object}
                 * @prop {Number} x
                 * @prop {Number} y
                 */
                let destination = {
                    x: this.input.mousePointer.x,
                    y: this.input.mousePointer.y
                };

                // each tile on the map is 24x24 pixels
                // the pathable map has double the amount of tiles but is the same width/height, so the pixel size for each tile is half (12x12)
                // this translates where the user clicked (raw pixel location on the screen) to where they clicked on the 12x12 tile map/array
                destination.x = Math.floor((this.camera.scrollX + destination.x + 0.5) / 12);
                destination.y = Math.floor((this.camera.scrollY + destination.y + 0.5) / 12);

                // if a tree is clicked, search for a clickable tile.
                if (easystarArray[destination.y][destination.x] === 1) {
                    let newDest = this.findNearbyWalkablePoint(destination.x, destination.y, easystarArray);
                    // if we found a tree, replace the bad click
                    if (newDest !== undefined) {
                        destination.x = newDest.x;
                        destination.y = newDest.y;
                    }
                }
                let movementInfo = {
                  requesterId: this.socket.id,
                  destination
                }
                this.socket.emit('tryNewMovement', movementInfo)

                // draw the "click to move" image and debug console logs
                this.drawMovementDestinationImage({
                    x: this.input.mousePointer.x + this.camera.scrollX,
                    y: this.input.mousePointer.y + this.camera.scrollY
                });
             }
        }, this);


        ////////////////////
        // BEGIN EASYSTAR //
        ////////////////////

        let easystarArray = [];

        for (let i = 0; i &lt; map.height * 2; i++) { // height*2 to double the times to path on
            let arr = [];
            let oneMore = false; // used to fix visual issue of walking on trees on the right side
            for (let j = 0; j &lt; map.width * 2; j++) { // width*2 to double the times to path on

                // there are twice as many pathable tiles are visual tiles.
                // this algorithm translates the current pathable tile to the larger, collidable tile
                let parentX = Math.floor((j + 0.5) / 2);
                let parentY = Math.floor((i + 0.5) / 2);

                if (treesLayer.getTileAt(parentX, parentY) !== null) {
                    arr.push(1); // if there is a tree, arr[j] = 1
                    oneMore = true;
                } else if (oneMore) {
                    arr.push(1);
                    oneMore = false; // additionally, if there is a tree 1 half-tile to the left, arr[j] = 1
                } else {
                    arr.push(0); // if there is NOT a tree, arr[j] = 0
                }

            }
            easystarArray.push(arr);
        }
    }


    ////////////
    // Update //
    ////////////

    update(time, delta) {

        // camera arrow keys update
        this.controls.update(delta);

        // get this player
        let myPlayer = this.players.find((player) => {
            return player.id == this.myId;
        });

        // if we found the player, continue update()
        if (myPlayer) {
            // minimap scrolling update
            this.minimap.scrollX = myPlayer.mage.x;
            this.minimap.scrollY = myPlayer.mage.y;

            // this makes the minimap ccamera follow with Phaser.Math.Clamp, which would be interesting: https://rexrainbow.github.io/phaser3-rex-notes/docs/site/clamp/
            // this.minimap.scrollX = Phaser.Math.Clamp(this.player.x - this.MINIMAP_WIDTH / 2, 0, 800);
            // this.minimap.scrollY = Phaser.Math.Clamp(this.player.y - this.MINIMAP_HEIGHT / 2, 0, 10000);
        }
    }


    //////////////////////
    // Custom Functions //
    //////////////////////

    // Calculate tweens here.
    calculateTweens(TICK_RATE) {

      this.players.forEach((player) => {
        if(player.mage.fromX &amp;&amp; player.mage.fromY &amp;&amp; player.mage.toX &amp;&amp; player.mage.toY) {

          var ex = player.mage.toX;
          var ey = player.mage.toY;

          this.tweens.add({
            targets: player.mage,
              x: {
                  value: ex,
                  duration: TICK_RATE
              },
              y: {
                  value: ey,
                  duration: TICK_RATE
              }
          })
        }

      })

    }



    /**
     * findNearbyWalkablePoint
     *
     * Could potentially do this recursively to always find a point, but it already feels solid this way.
     *
     * @param {int}	x - x location to search near
     * @param {int}	y - y location to search near
     * @param {easystar[]}	easystarArray - this is the parameter easystarArray
     *
     * @return {Phaser.Math.Vector2}
     *
     */
    findNearbyWalkablePoint(x, y, easystarArray) {
        let destVec = new Phaser.Math.Vector2(x, y);
        let destLook = destVec.clone();
        let destLookArr = [];

        if (easystarArray[destVec.y][destVec.x] === 0) {
            return destVec;
        } else {
            destLookArr.push(destLook.add(Phaser.Math.Vector2.UP));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
            destLook = destVec.clone();
            destLookArr.push(destLook.add(Phaser.Math.Vector2.DOWN));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
            destLook = destVec.clone();
            destLookArr.push(destLook.add(Phaser.Math.Vector2.LEFT));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
            destLook = destVec.clone();
            destLookArr.push(destLook.add(Phaser.Math.Vector2.RIGHT));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
            destLook = destVec.clone();
            destLookArr.push(destLook.add(Phaser.Math.Vector2.UP).add(Phaser.Math.Vector2.RIGHT));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
            destLook = destVec.clone();
            destLookArr.push(destLook.add(Phaser.Math.Vector2.UP).add(Phaser.Math.Vector2.RIGHT));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
            destLook = destVec.clone();
            destLookArr.push(destLook.add(Phaser.Math.Vector2.UP).add(Phaser.Math.Vector2.RIGHT));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
            destLook = destVec.clone();
            destLookArr.push(destLook.add(Phaser.Math.Vector2.UP).add(Phaser.Math.Vector2.RIGHT));
            if (easystarArray[destLook.y][destLook.x] === 0) {
                return destLook;
            }
        }
    }


    /**
     * drawMovementDestinationImage
     *
     * @param {object}	destination - this is the destination location
     * @param {int} destination.x - the X coordination for the destination
     * @param {int} destination.y - the X coordination for the destination
     *
     */
    drawMovementDestinationImage(destination) {
        // image duration in ms
        const DURATION = 0.5 * 1000;
        let clickImg = this.add.image(destination.x, destination.y, 'movementClick');
        clickImg.setScale(2.5, 2.5);

        //this.sound.play('movementClickSound', {volume: 0.25});
        this.sound.play('movementClickBlip', {
            volume: 0.01
        });

        // this deletes the image after &lt;ms> DURATION
        setTimeout(() => {
            clickImg.destroy();
        }, DURATION);
    }
}
</code></pre>
        </article>
    </section>




    </div>

    <footer class="footer" id="footer">
      
    </footer>

    <script src="scripts/third-party/prettify.js"></script>
    <script src="scripts/third-party/lang-css.js"></script>
    <script type="text/javascript" src="scripts/misc.js"></script>

    <script>prettyPrint();</script>
    <script src="scripts/linenumber.js"></script>
    <script src="scripts/fix-code-block.js"></script>
    <script src="scripts/fix-navbar.js"></script>
    
      <script src="scripts/search.js"></script>
      <script src="scripts/third-party/fuse.js"></script>
      <script>
        var list = [{"title":"Circle","link":"<a href=\"Circle.html\">Circle</a>"},{"title":"ColorData","link":"<a href=\"ColorData.html\">ColorData</a>"},{"title":"Location","link":"<a href=\"Location.html\">Location</a>"},{"title":"Location#toString","link":"<a href=\"Location.html#toString\">Location &rtrif; toString</a>"},{"title":"MainMenu","link":"<a href=\"MainMenu.html\">MainMenu</a>"},{"title":"MainMenu#create","link":"<a href=\"MainMenu.html#create\">MainMenu &rtrif; create</a>"},{"title":"MainMenu#createButton","link":"<a href=\"MainMenu.html#createButton\">MainMenu &rtrif; createButton</a>"},{"title":"MainMenu#init","link":"<a href=\"MainMenu.html#init\">MainMenu &rtrif; init</a>"},{"title":"Rectangle","link":"<a href=\"Rectangle.html\">Rectangle</a>"},{"title":"Rectangle#toString","link":"<a href=\"Rectangle.html#toString\">Rectangle &rtrif; toString</a>"},{"title":"UIHelper","link":"<a href=\"UIHelper.html\">UIHelper</a>"},{"title":"UIHelper.createBackButton","link":"<a href=\"UIHelper.html#.createBackButton\">UIHelper.createBackButton &rtrif; undefined</a>"},{"title":"UIHelper.createButton","link":"<a href=\"UIHelper.html#.createButton\">UIHelper.createButton &rtrif; undefined</a>"},{"title":"UIHelper.createRadioButton","link":"<a href=\"UIHelper.html#.createRadioButton\">UIHelper.createRadioButton &rtrif; undefined</a>"},{"title":"UIHelper.getBackButton","link":"<a href=\"UIHelper.html#.getBackButton\">UIHelper.getBackButton &rtrif; undefined</a>"},{"title":"UIHelper.getButton","link":"<a href=\"UIHelper.html#.getButton\">UIHelper.getButton &rtrif; undefined</a>"},{"title":"UIHelper.getFont","link":"<a href=\"UIHelper.html#.getFont\">UIHelper.getFont &rtrif; undefined</a>"},{"title":"UIHelper.getHealthBar","link":"<a href=\"UIHelper.html#.getHealthBar\">UIHelper.getHealthBar &rtrif; undefined</a>"},{"title":"UIHelper.getManaColors","link":"<a href=\"UIHelper.html#.getManaColors\">UIHelper.getManaColors &rtrif; undefined</a>"},{"title":"UIHelper.getManaOrb","link":"<a href=\"UIHelper.html#.getManaOrb\">UIHelper.getManaOrb &rtrif; undefined</a>"},{"title":"UIHelper.getRuneSlot","link":"<a href=\"UIHelper.html#.getRuneSlot\">UIHelper.getRuneSlot &rtrif; undefined</a>"},{"title":"UIHelper.getScreenHeight","link":"<a href=\"UIHelper.html#.getScreenHeight\">UIHelper.getScreenHeight &rtrif; undefined</a>"},{"title":"UIHelper.getScreenWidth","link":"<a href=\"UIHelper.html#.getScreenWidth\">UIHelper.getScreenWidth &rtrif; undefined</a>"},{"title":"UIHelper.getUIColors","link":"<a href=\"UIHelper.html#.getUIColors\">UIHelper.getUIColors &rtrif; undefined</a>"},{"title":"UIHelper.setCameraBackgroundColor","link":"<a href=\"UIHelper.html#.setCameraBackgroundColor\">UIHelper.setCameraBackgroundColor &rtrif; undefined</a>"},{"title":"UIHelper.shuffle","link":"<a href=\"UIHelper.html#.shuffle\">UIHelper.shuffle &rtrif; undefined</a>"},{"title":"drawMovementDestinationImage","link":"<a href=\"global.html#drawMovementDestinationImage\">drawMovementDestinationImage</a>"},{"title":"findNearbyWalkablePoint","link":"<a href=\"global.html#findNearbyWalkablePoint\">findNearbyWalkablePoint</a>"}];
        var options = 
          setupSearch(list, options)
      </script>
    

    

    

    

    


  </body>

</html>
